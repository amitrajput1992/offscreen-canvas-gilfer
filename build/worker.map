{"version":3,"sources":["worker.js"],"names":["lastTime","delayCompensation","isRunning","frames","frameIndex","width","height","disposeFrame","canvas","ctx","loopCount","loops","createBufferCanvas","frame","bufferCanvas","bufferContext","imageData","OffscreenCanvas","getContext","createImageData","data","set","pixels","putImageData","x","y","start","Date","valueOf","setTimeout","nextFrame","requestAnimationFrame","nextFrameRender","onFrame","enqueueNextFrame","i","buffer","getNextDisposeFrame","onDrawFrame","drawImage","postMessage","type","actualDelay","delta","frameDelay","advanceFrame","delay","length","stop","disposal","clearRect","saved","getImageData","reset","onmessage","e","detail"],"mappings":";AAOA,IAAIA,EACAC,EACAC,EAGAC,EAAS,GACTC,EAAa,EACbC,EAAQ,EACRC,EAAS,EACTC,EAAe,KACfC,EAAS,KACTC,EAAM,KACNC,EAAY,EACZC,EAAQ,EA+BZ,SAASC,EAAmBC,GACtBC,IAAAA,EAAcC,EAAeC,EAM1BF,OAHPE,GADAD,GADAD,EAAe,IAAIG,gBAAgBJ,EAAMR,MAAOQ,EAAMP,SACzBY,WAAW,OACdC,gBAAgBd,EAAOC,IACvCc,KAAKC,IAAIR,EAAMS,QACzBP,EAAcQ,aAAaP,GAAYH,EAAMW,GAAIX,EAAMY,GAChDX,EAwBT,SAASY,IACP1B,GAAW,IAAI2B,MAAOC,UACtB3B,EAAoB,EACpBC,GAAY,EACZ2B,WAAWC,EAAW,GAGxB,SAASA,IACPC,sBAAsBC,GAGxB,SAASA,IACH9B,IAIJ+B,EADY9B,EAAOC,GACJA,GACf8B,KAQF,SAASD,EAAQpB,EAAOsB,GAClBtB,EAAMuB,SACRvB,EAAMuB,OAASxB,EAAmBC,EAAOR,EAAOC,IAEvB,mBAAjBC,GACRA,IAEFA,EAAe8B,EAAoBxB,GACnCyB,EAAYzB,EAAOsB,GAQrB,SAASG,EAAYzB,EAAOsB,GAC1B1B,EAAI8B,UAAU1B,EAAMuB,OAAQvB,EAAMW,EAAGX,EAAMY,GAC3Ce,YAAY,CACVC,KAAM,gBAIV,SAASP,IACHQ,IAAAA,EAAaC,EAAO9B,EAAO+B,EAExB1C,IADP2C,IACO3C,GAAW,CAQZwC,GAPJ7B,EAAQV,EAAOC,GACfuC,GAAQ,IAAIhB,MAAOC,UAAY5B,EAC/BA,GAAY2C,EACZ1C,GAAqB0C,EAErBD,GADAE,EAA2B,GAAd/B,EAAMiC,OACQ7C,EAC3BA,GAAqB2C,IACjBF,EAAc,GAAdA,CAIFb,WAAWC,EAAWY,GACtB,MAJAG,KASN,SAASA,KACPzC,GAAc,IACID,EAAO4C,SACL,IAAdrC,GAAmBA,IAAcC,EACnCqC,KAEA5C,EAAa,EACbO,GAAS,IAKf,SAAS0B,EAAoBxB,GACpBA,OAAAA,EAAMoC,UACN,KAAA,EACI,OAAA,WACLxC,EAAIyC,UAAU,EAAG,EAAG7C,EAAOC,IAG1B,KAAA,EACC6C,IAAAA,EAAQ1C,EAAI2C,aAAa,EAAG,EAAG/C,EAAOC,GACnC,OAAA,WACLG,EAAIc,aAAa4B,EAAO,EAAG,KAMnC,SAASH,IACP9C,GAAY,EAGd,SAASmD,IACPjD,EAAa,EACbO,EAAQ,EAnKV2C,UAAY,SAASC,GACbC,IAAAA,EAASD,EAAEnC,KAAKoC,OACfD,OAAAA,EAAEnC,KAAKqB,MACP,IAAA,OACHtC,EAASqD,EAAOrD,OAChBE,EAAQmD,EAAOnD,MACfC,EAASkD,EAAOlD,OAChBI,EAAY8C,EAAO9C,UACnB,MAGG,IAAA,YACHF,EAASgD,EAAOhD,OAChBC,EAAMD,EAAOU,WAAW,MACxB,MAGG,IAAA,QACHQ,IACA,MAGG,IAAA,OACHsB","file":"worker.map","sourceRoot":"../src/app","sourcesContent":["/**\n * Use this file to perform any heavy operations such as generating frames of the gif on the canvas.\n * We will be using OffscreenCanvas() here to print frames and send blobs to main thread for treatment\n */\n\n// define vars required\n// internal\nlet lastTime;\nlet delayCompensation;\nlet isRunning;\n\n// external\nlet frames = [];\nlet frameIndex = 0;\nlet width = 0;\nlet height = 0;\nlet disposeFrame = null;\nlet canvas = null;\nlet ctx = null;\nlet loopCount = 0;\nlet loops = 0;\n\nonmessage = function(e) {\n  const detail = e.data.detail;\n  switch(e.data.type) {\n    case 'init': {\n      frames = detail.frames;\n      width = detail.width;\n      height = detail.height;\n      loopCount = detail.loopCount;\n      break;\n    }\n\n    case 'canvasCtx': {\n      canvas = detail.canvas;\n      ctx = canvas.getContext('2d');\n      break;\n    }\n\n    case 'start': {\n      start();\n      break;\n    }\n\n    case 'stop': {\n      stop();\n      break;\n    }\n  }\n};\n\nfunction createBufferCanvas(frame) {\n  let bufferCanvas, bufferContext, imageData;\n  bufferCanvas = new OffscreenCanvas(frame.width, frame.height);\n  bufferContext = bufferCanvas.getContext('2d');\n  imageData = bufferContext.createImageData(width, height);\n  imageData.data.set(frame.pixels);\n  bufferContext.putImageData(imageData, -frame.x, -frame.y);\n  return bufferCanvas;\n}\n\n/*---\n  head : 'animator.animateInCanvas()'\n  text :\n    - >\n      This method prepares the canvas to be drawn into and sets up\n      the callbacks for each frame while the animation is running.\n    - >\n      To change how each frame is drawn into the canvas, override\n      <b>animator.onDrawFrame()</b> before calling this method.\n      If <b>animator.onDrawFrame()</b> is not set, we simply draw\n      the frame directly into the canvas as is.\n    - >\n      You may also override <b>animator.onFrame()</b> before calling\n      this method. onFrame handles the lazy construction of canvas\n      buffers for each frame as well as the disposal method for each frame.\n  args :\n    setDimensions : 'OPTIONAL. If true, the canvas width/height will be set to match the GIF. default: true.'\n\n    animateInCanvas -> start -> onFrame -> onDrawFrame\n\n   */\nfunction start () {\n  lastTime = new Date().valueOf();\n  delayCompensation = 0;\n  isRunning = true;\n  setTimeout(nextFrame, 0);\n}\n\nfunction nextFrame() {\n  requestAnimationFrame(nextFrameRender);\n}\n\nfunction nextFrameRender() {\n  if(!isRunning) {\n    return;\n  }\n  let frame = frames[frameIndex];\n  onFrame(frame, frameIndex);\n  enqueueNextFrame();\n}\n\n/**\n * Called on each frame\n * @param frame\n * @param i\n */\nfunction onFrame(frame, i) {\n  if(!frame.buffer) {\n    frame.buffer = createBufferCanvas(frame, width, height);\n  }\n  if(typeof disposeFrame === 'function') {\n    disposeFrame();\n  }\n  disposeFrame = getNextDisposeFrame(frame);\n  onDrawFrame(frame, i);\n}\n\n/**\n * draw the frame on the canvas\n * @param frame\n * @param i: frame index\n */\nfunction onDrawFrame(frame, i) {\n  ctx.drawImage(frame.buffer, frame.x, frame.y);\n  postMessage({\n    type: 'onDrawFrame',\n  });\n}\n\nfunction enqueueNextFrame() {\n  let actualDelay, delta, frame, frameDelay;\n  advanceFrame();\n  while (isRunning) {\n    frame = frames[frameIndex];\n    delta = new Date().valueOf() - lastTime;\n    lastTime += delta;\n    delayCompensation += delta;\n    frameDelay = frame.delay * 10;\n    actualDelay = frameDelay - delayCompensation;\n    delayCompensation -= frameDelay;\n    if (actualDelay < 0) {\n      advanceFrame();\n      continue;\n    } else {\n      setTimeout(nextFrame, actualDelay);\n      break;\n    }\n  }\n}\n\nfunction advanceFrame() {\n  frameIndex += 1;\n  if (frameIndex >= frames.length) {\n    if (loopCount !== 0 && loopCount === loops) {\n      stop();\n    } else {\n      frameIndex = 0;\n      loops += 1;\n    }\n  }\n}\n\nfunction getNextDisposeFrame(frame) {\n  switch(frame.disposal) {\n    case 2: {\n      return function() {\n        ctx.clearRect(0, 0, width, height);\n      }\n    }\n    case 3: {\n      let saved = ctx.getImageData(0, 0, width, height);\n      return function() {\n        ctx.putImageData(saved, 0, 0);\n      }\n    }\n  }\n}\n\nfunction stop() {\n  isRunning = false;\n}\n\nfunction reset() {\n  frameIndex = 0;\n  loops = 0;\n}\n"]}