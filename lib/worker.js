"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bridgeCode = void 0;

/**
 * Use this file to perform any heavy operations such as generating frames of the gif on the canvas.
 * We will be using OffscreenCanvas() here to print frames and send blobs to main thread for treatment
 */
// define vars required
// internal
var bridgeCode = "let lastTime;\nlet delayCompensation;\nlet isRunning;\n\n// external\nlet frames = [];\nlet frameIndex = 0;\nlet width = 0;\nlet height = 0;\nlet disposeFrame = null;\nlet canvas = null;\nlet ctx = null;\nlet loopCount = 0;\nlet loops = 0;\nlet renderWidth = 0;\nlet renderHeight = 0;\n\nonmessage = function(e) {\n  const detail = e.data.detail;\n  switch(e.data.type) {\n    case 'init': {\n      frames = detail.frames;\n      width = detail.width;\n      height = detail.height;\n      loopCount = detail.loopCount;\n      renderWidth = detail.renderWidth;\n      renderHeight = detail.renderHeight;\n      break;\n    }\n\n    case 'canvasCtx': {\n      canvas = detail.canvas;\n      ctx = canvas.getContext('2d');\n      break;\n    }\n\n    case 'start': {\n      start();\n      break;\n    }\n\n    case 'stop': {\n      stop();\n      break;\n    }\n  }\n};\n\nfunction createBufferCanvas(frame) {\n  let bufferCanvas, bufferContext, imageData;\n  bufferCanvas = new OffscreenCanvas(frame.width, frame.height);\n  bufferContext = bufferCanvas.getContext('2d');\n  imageData = bufferContext.createImageData(width, height);\n  imageData.data.set(frame.pixels);\n  bufferContext.putImageData(imageData, -frame.x, -frame.y);\n  return bufferCanvas;\n}\n\n/*---\n  head : 'animator.animateInCanvas()'\n  text :\n    - >\n      This method prepares the canvas to be drawn into and sets up\n      the callbacks for each frame while the animation is running.\n    - >\n      To change how each frame is drawn into the canvas, override\n      <b>animator.onDrawFrame()</b> before calling this method.\n      If <b>animator.onDrawFrame()</b> is not set, we simply draw\n      the frame directly into the canvas as is.\n    - >\n      You may also override <b>animator.onFrame()</b> before calling\n      this method. onFrame handles the lazy construction of canvas\n      buffers for each frame as well as the disposal method for each frame.\n  args :\n    setDimensions : 'OPTIONAL. If true, the canvas width/height will be set to match the GIF. default: true.'\n\n    animateInCanvas -> start -> onFrame -> onDrawFrame\n\n   */\nfunction start () {\n  lastTime = new Date().valueOf();\n  delayCompensation = 0;\n  isRunning = true;\n  setTimeout(nextFrame, 0);\n}\n\nfunction nextFrame() {\n  requestAnimationFrame(nextFrameRender);\n}\n\nfunction nextFrameRender() {\n  if(!isRunning) {\n    return;\n  }\n  let frame = frames[frameIndex];\n  onFrame(frame, frameIndex);\n  enqueueNextFrame();\n}\n\n/**\n * Called on each frame\n * @param frame\n * @param i\n */\nfunction onFrame(frame, i) {\n  if(!frame.buffer) {\n    frame.buffer = createBufferCanvas(frame);\n  }\n  if(typeof disposeFrame === 'function') {\n    disposeFrame();\n  }\n  disposeFrame = getNextDisposeFrame(frame);\n  onDrawFrame(frame, i);\n}\n\n/**\n * draw the frame on the canvas\n * @param frame\n * @param i: frame index\n */\nfunction onDrawFrame(frame, i) {\n  ctx.drawImage(frame.buffer, frame.x, frame.y); \n  postMessage({\n    type: 'onDrawFrame',\n    frameIndex: i\n  });\n}\n\nfunction enqueueNextFrame() {\n  let actualDelay, delta, frame, frameDelay;\n  advanceFrame();\n  while (isRunning) {\n    frame = frames[frameIndex];\n    delta = new Date().valueOf() - lastTime;\n    lastTime += delta;\n    delayCompensation += delta;\n    frameDelay = frame.delay * 10;\n    actualDelay = frameDelay - delayCompensation;\n    delayCompensation -= frameDelay;\n    if (actualDelay < 0) {\n      advanceFrame();\n      continue;\n    } else {\n      setTimeout(nextFrame, actualDelay);\n      break;\n    }\n  }\n}\n\nfunction advanceFrame() {\n  frameIndex += 1;\n  if (frameIndex >= frames.length) {\n    if (loopCount !== 0 && loopCount === loops) {\n      stop();\n    } else {\n      frameIndex = 0;\n      loops += 1;\n    }\n  }\n}\n\nfunction getNextDisposeFrame(frame) {\n  switch(frame.disposal) {\n    case 2: {\n      return function() {\n        ctx.clearRect(0, 0, width, height);\n      }\n    }\n    case 3: {\n      let saved = ctx.getImageData(0, 0, width, height);\n      return function() {\n        ctx.putImageData(saved, 0, 0);\n      }\n    }\n  }\n}\n\nfunction stop() {\n  isRunning = false;\n}\n\nfunction reset() {\n  frameIndex = 0;\n  loops = 0;\n}\n";
exports.bridgeCode = bridgeCode;